// Generated by CoffeeScript 1.9.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  module.exports = function(BasePlugin) {
    var CleancssPlugin;
    return CleancssPlugin = (function(superClass) {
      extend(CleancssPlugin, superClass);

      function CleancssPlugin() {
        return CleancssPlugin.__super__.constructor.apply(this, arguments);
      }

      CleancssPlugin.prototype.name = 'cleancss';

      CleancssPlugin.prototype.config = {
        cleancssOpts: {
          keepSpecialComments: '*',
          keepBreaks: false,
          benchmark: false,
          processImport: true,
          rebase: true,
          advanced: false,
          debug: false
        },
        environments: {
          development: {
            enabled: false
          }
        }
      };

      CleancssPlugin.prototype.writeAfter = function(opts, next) {
        var CleanCSS, TaskGroup, config, docpad, docpadConfig, plugin, tasks;
        CleanCSS = require('clean-css');
        TaskGroup = require('taskgroup').TaskGroup;
        plugin = this;
        config = this.getConfig();
        docpad = this.docpad;
        docpadConfig = docpad.getConfig();
        tasks = new TaskGroup({
          concurrency: 0
        }).done(next);
        opts.collection.findAll({
          cleancss: {
            $exists: true
          }
        }).each(function(file) {
          if (file.get('cleancss') === false) {
            return;
          }
          return tasks.addTask(function(complete) {
            var cleanOpts, content, filePath, key, ref, value;
            content = file.get('contentRendered');
            filePath = file.getPath();
            cleanOpts = file.get('cleancss');
            if (cleanOpts === true) {
              cleanOpts = {};
            }
            cleanOpts.relativeTo = file.get('outDirPath');
            cleanOpts.root = docpadConfig.outPath;
            if (cleanOpts.processImport && content.indexOf('@import') !== -1) {
              file.setMetaDefaults({
                'referencesOthers': true
              });
            }
            ref = config.cleancssOpts;
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              value = ref[key];
              if (cleanOpts[key] == null) {
                cleanOpts[key] = value;
              }
            }
            return new CleanCSS(cleanOpts).minify(content, function(errors, result) {
              var err, error, ref1, ref2, warn;
              if ((ref1 = result.errors) != null ? ref1.length : void 0) {
                err = new Error(("The following errors occured cleaning the css file: " + filePath + "\n") + ((function() {
                  var i, len, ref2, results;
                  ref2 = result.errors;
                  results = [];
                  for (i = 0, len = ref2.length; i < len; i++) {
                    error = ref2[i];
                    results.push(error.stack);
                  }
                  return results;
                })()).join('\n\n'));
                return complete(err);
              }
              if ((ref2 = result.warnings) != null ? ref2.length : void 0) {
                warn = new Error(("The following warnings occured cleaning the css file: " + filePath + "\n") + result.warnings.join('\n\n'));
                docpad.warn(warn);
              }
              file.set({
                contentRendered: result.styles,
                contentRenderedWithoutLayouts: result.styles
              });
              return file.action('write', complete);
            });
          });
        });
        tasks.run();
        return this;
      };

      return CleancssPlugin;

    })(BasePlugin);
  };

}).call(this);
